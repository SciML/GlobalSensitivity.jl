var documenterSearchIndex = {"docs":
[{"location":"methods/regression/#Regression-Method","page":"Regression Method","title":"Regression Method","text":"","category":"section"},{"location":"methods/regression/","page":"Regression Method","title":"Regression Method","text":"RegressionGSA","category":"page"},{"location":"methods/regression/#GlobalSensitivity.RegressionGSA","page":"Regression Method","title":"GlobalSensitivity.RegressionGSA","text":"RegressionGSA(; rank::Bool = false)\n\nrank::Bool = false: Flag determining whether to also run a rank regression analysis\n\nProviding this to gsa results in a calculation of the following statistics, provided as a RegressionGSAResult. If the function f to be analyzed is of dimensionality f R^n - R^m, then these coefficients are returned as a matrix, with the corresponding statistic in the (i, j)` entry.\n\npearson: This is equivalent to the correlation coefficient matrix between input and output. The rank version is known as the Spearman coefficient.\nstandard_regression: Standard regression coefficients, also known as sigma-normalized derivatives\npartial_correlation: Partial correlation coefficients, related to the precision matrix and a measure of the correlation of linear models of the\n\nMethod Details\n\nIt is possible to fit a linear model explaining the behavior of Y given the values of X, provided that the sample size n is sufficiently large (at least n > d).\n\nThe measures provided for this analysis by us in GlobalSensitivity.jl are\n\na) Pearson Correlation Coefficient:\n\nr = fracsum_i=1^n (x_i - overlinex)(y_i - overliney)sqrtsum_i=1^n (x_i - overlinex)^2(y_i - overliney)^2\n\nb) Standard Regression Coefficient (SRC):\n\nSRC_j = beta_j sqrtfracVar(X_j)Var(Y)\n\nwhere beta_j is the linear regression coefficient associated to X_j. This is also known as a sigma-normalized derivative.\n\nc) Partial Correlation Coefficient (PCC):\n\nPCC_j = rho(X_j - hatX_-jY_j - hatY_-j)\n\nwhere hatX_-j is the prediction of the linear model, expressing X_j with respect to the other inputs and hatY_-j is the prediction of the linear model where X_j is absent. PCC measures the sensitivity of Y to X_j when the effects of the other inputs have been canceled.\n\nIf rank is set to true, then the rank coefficients are also calculated.\n\nAPI\n\ngsa(f, method::RegressionGSA, p_range::AbstractVector; samples::Int, batch = false)\ngsa(X, Y, method::RegressionGSA)\n\nExample\n\nusing GlobalSensitivity\n\nfunction linear_batch(X)\n    A= 7\n    B= 0.1\n    @. A*X[1,:]+B*X[2,:]\nend\nfunction linear(X)\n    A= 7\n    B= 0.1\n    A*X[1]+B*X[2]\nend\n\np_range = [[-1, 1], [-1, 1]]\nreg = gsa(linear_batch, RegressionGSA(), p_range; batch = true)\n\nreg = gsa(linear, RegressionGSA(), p_range; batch = false)\nreg = gsa(linear, RegressionGSA(true), p_range; batch = false) #with rank coefficients\n\nX = QuasiMonteCarlo.sample(1000, [-1, -1], [1, 1], QuasiMonteCarlo.SobolSample())\nY = reshape(linear.([X[:, i] for i in 1:1000]), 1, 1000)\nreg_mat = gsa(X, Y, RegressionGSA(true))\n\n\n\n\n\n","category":"type"},{"location":"tutorials/parallelized_gsa/#Parallelized-Morris-and-Sobol-Sensitivity-Analysis-of-an-ODE","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"","category":"section"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"Let's run GSA on the Lotka-Volterra model to and study the sensitivity of the maximum of predator population and the average prey population.","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"using GlobalSensitivity, Statistics, OrdinaryDiffEq, QuasiMonteCarlo, Plots","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"First, let's define our model:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"function f(du,u,p,t)\n  du[1] = p[1]*u[1] - p[2]*u[1]*u[2] #prey\n  du[2] = -p[3]*u[2] + p[4]*u[1]*u[2] #predator\nend\nu0 = [1.0;1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(f,u0,tspan,p)\nt = collect(range(0, stop=10, length=200))","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"Now, let's create a function that takes in a parameter set and calculates the maximum of the predator population and the average of the prey population for those parameter values. To do this, we will make use of the remake function, which creates a new ODEProblem, and use the p keyword argument to set the new parameters:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"f1 = function (p)\n  prob1 = remake(prob;p=p)\n  sol = solve(prob1,Tsit5();saveat=t)\n  [mean(sol[1,:]), maximum(sol[2,:])]\nend","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"Now, let's perform a Morris global sensitivity analysis on this model. We specify that the parameter range is [1,5] for each of the parameters, and thus call:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"m = gsa(f1,Morris(total_num_trajectory=1000,num_trajectory=150),[[1,5],[1,5],[1,5],[1,5]])","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"Let's get the means and variances from the MorrisResult struct.","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"m.means","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"m.variances","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"Let's plot the result","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"scatter(m.means[1,:], m.variances[1,:],series_annotations=[:a,:b,:c,:d],color=:gray)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"scatter(m.means[2,:], m.variances[2,:],series_annotations=[:a,:b,:c,:d],color=:gray)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"For the Sobol method, we can similarly do:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"m = gsa(f1,Sobol(),[[1,5],[1,5],[1,5],[1,5]],samples=1000)","category":"page"},{"location":"tutorials/parallelized_gsa/#Direct-Use-of-Design-Matrices","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Direct Use of Design Matrices","text":"","category":"section"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"For the Sobol Method, we can have more control over the sampled points by generating design matrices. Doing it in this manner lets us directly specify a quasi-Monte Carlo sampling method for the parameter space. Here we use QuasiMonteCarlo.jl to generate the design matrices as follows:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"samples = 500\nlb = [1.0, 1.0, 1.0, 1.0]\nub = [5.0, 5.0, 5.0, 5.0]\nsampler = SobolSample()\nA,B = QuasiMonteCarlo.generate_design_matrices(samples,lb,ub,sampler)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"and now we tell it to calculate the Sobol indices on these designs for the function f1 we defined in the Lotka Volterra example:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"sobol_result = gsa(f1,Sobol(),A,B)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"We plot the first order and total order Sobol Indices for the parameters (a and b).","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"p1 = bar([\"a\",\"b\",\"c\",\"d\"],sobol_result.ST[1,:],title=\"Total Order Indices prey\",legend=false)\np2 = bar([\"a\",\"b\",\"c\",\"d\"],sobol_result.S1[1,:],title=\"First Order Indices prey\",legend=false)\np1_ = bar([\"a\",\"b\",\"c\",\"d\"],sobol_result.ST[2,:],title=\"Total Order Indices predator\",legend=false)\np2_ = bar([\"a\",\"b\",\"c\",\"d\"],sobol_result.S1[2,:],title=\"First Order Indices predator\",legend=false)\nplot(p1,p2,p1_,p2_)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"(Image: sobolbars)","category":"page"},{"location":"tutorials/parallelized_gsa/#Parallelizing-the-Global-Sensitivity-Analysis","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelizing the Global Sensitivity Analysis","text":"","category":"section"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"In all of the previous examples, f(p) was calculated serially. However, we can parallelize our computations by using the batch interface. In the batch interface, each column p[:,i] is a set of parameters, and we output a column for each set of parameters. Here we showcase using the Ensemble Interface to use EnsembleGPUArray to perform automatic multithreaded-parallelization of the ODE solves.","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"function f(du,u,p,t)\n  du[1] = p[1]*u[1] - p[2]*u[1]*u[2] #prey\n  du[2] = -p[3]*u[2] + p[4]*u[1]*u[2] #predator\nend\n\nu0 = [1.0;1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(f,u0,tspan,p)\nt = collect(range(0, stop=10, length=200))\n\nf1 = function (p)\n  prob_func(prob,i,repeat) = remake(prob;p=p[:,i])\n  ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)\n  sol = solve(ensemble_prob,Tsit5(),EnsembleThreads();saveat=t,trajectories=size(p,2))\n  # Now sol[i] is the solution for the ith set of parameters\n  out = zeros(2,size(p,2))\n  for i in 1:size(p,2)\n    out[1,i] = mean(sol[i][1,:])\n    out[2,i] = maximum(sol[i][2,:])\n  end\n  out\nend","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"And now to do the parallelized calls we simply add the batch=true keyword argument:","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"sobol_result = gsa(f1,Sobol(),A,B,batch=true)","category":"page"},{"location":"tutorials/parallelized_gsa/","page":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","title":"Parallelized Morris and Sobol Sensitivity Analysis of an ODE","text":"This user-side parallelism thus allows you to take control, and thus for example you can use DiffEqGPU.jl for automated GPU-parallelism of the ODE-based global sensitivity analysis!","category":"page"},{"location":"methods/fractional/#Fractional-Factorial-Method","page":"Fractional Factorial Method","title":"Fractional Factorial Method","text":"","category":"section"},{"location":"methods/fractional/","page":"Fractional Factorial Method","title":"Fractional Factorial Method","text":"FractionalFactorial","category":"page"},{"location":"methods/fractional/#GlobalSensitivity.FractionalFactorial","page":"Fractional Factorial Method","title":"GlobalSensitivity.FractionalFactorial","text":"FractionalFactorial()\n\nFractionalFactorial does not have any keyword arguments.\n\nMethod Details\n\nFractional Factorial method creates a design matrix by utilising Hadamard Matrix and uses it run simulations of the input model. The main effects are then evaluated by dot product between the contrast for the parameter and the vector of simulation results. The corresponding main effects and variance, i.e. square of the main effects are returned as results for Fractional Factorial method.\n\nAPI\n\ngsa(f, method::FractionalFactorial; num_params, p_range = nothing, kwargs...)\n\nExample\n\nusing GlobalSensitivity, Test\n\nf = X -> X[1] + 2 * X[2] + 3 * X[3] + 4 * X[7] * X[12]\nres1 = gsa(f,FractionalFactorial(),num_params = 12,samples=10)\n\n\n\n\n\n","category":"type"},{"location":"methods/easi/#EASI-Method","page":"EASI Method","title":"EASI Method","text":"","category":"section"},{"location":"methods/easi/","page":"EASI Method","title":"EASI Method","text":"EASI","category":"page"},{"location":"methods/easi/#GlobalSensitivity.EASI","page":"EASI Method","title":"GlobalSensitivity.EASI","text":"EASI(; max_harmonic::Int = 10, dct_method::Bool = false)\n\nmax_harmonic: Maximum harmonic of the input frequency for which the output power spectrum is analyzed for. Defaults to 10.\ndct_method: Use Discrete Cosine Transform method to compute the power spectrum. Defaults to false.\n\nMethod Details\n\nThe EASI method is a Fourier-based technique for performing variance-based methods of global sensitivity analysis for the computation of first order effects (Sobol’ indices), hence belonging into the same class of algorithms as FAST and RBD. It is a computationally cheap method for which existing data can be used. Unlike the FAST and RBD methods which use a specially generated sample set that contains suitable frequency data for the input factors, in EASI these frequencies are introduced by sorting and shuffling the available input samples.\n\nAPI\n\ngsa(f, method::EASI, p_range; samples, batch = false)\ngsa(X, Y, method::EASI)\n\nExample\n\nusing GlobalSensitivity, Test\n\nfunction ishi_batch(X)\n    A= 7\n    B= 0.1\n    @. sin(X[1,:]) + A*sin(X[2,:])^2+ B*X[3,:]^4 *sin(X[1,:])\nend\nfunction ishi(X)\n    A= 7\n    B= 0.1\n    sin(X[1]) + A*sin(X[2])^2+ B*X[3]^4 *sin(X[1])\nend\n\nlb = -ones(4)*π\nub = ones(4)*π\n\nres1 = gsa(ishi,EASI(),[[lb[i],ub[i]] for i in 1:4],samples=15000)\nres2 = gsa(ishi_batch,EASI(),[[lb[i],ub[i]] for i in 1:4],samples=15000,batch=true)\n\nX = QuasiMonteCarlo.sample(15000, lb, ub, QuasiMonteCarlo.SobolSample())\nY = ishi.([X[:, i] for i in 1:15000])\n\nres1 = gsa(X, Y, EASI())\nres1 = gsa(X, Y, EASI(; dct_method = true))\n\n\n\n\n\n","category":"type"},{"location":"methods/efast/#eFAST-Method","page":"eFAST Method","title":"eFAST Method","text":"","category":"section"},{"location":"methods/efast/","page":"eFAST Method","title":"eFAST Method","text":"eFAST","category":"page"},{"location":"methods/efast/#GlobalSensitivity.eFAST","page":"eFAST Method","title":"GlobalSensitivity.eFAST","text":"eFAST(; num_harmonics::Int = 4)\n\nnum_harmonics: the number of harmonics to sum in the Fourier series decomposition, this defaults to 4.\n\nMethod Details\n\neFAST offers a robust, especially at low sample size, and computationally efficient procedure to get the first and total order indices as discussed in Sobol. It utilizes monodimensional Fourier decomposition along a curve exploring the parameter space. The curve is defined by a set of parametric equations,\n\nx_i(s) = G_i(sin ω_is)  i=12  N\n\nwhere s is a scalar variable varying over the range -  s  +, G_i are transformation functions and ω_i  i=12N is a set of different (angular) frequencies, to be properly selected, associated with each factor for all N (samples) number of parameter sets. For more details on the transformation used and other implementation details you can go through  A. Saltelli et al..\n\nAPI\n\ngsa(f, method::eFAST, p_range::AbstractVector; samples::Int, batch = false,\n         distributed::Val{SHARED_ARRAY} = Val(false),\n         rng::AbstractRNG = Random.default_rng(), kwargs...) where {SHARED_ARRAY}\n\nExample\n\nBelow we show use of eFAST on the Ishigami function.\n\nusing GlobalSensitivity, QuasiMonteCarlo\n\nfunction ishi(X)\n    A= 7\n    B= 0.1\n    sin(X[1]) + A*sin(X[2])^2+ B*X[3]^4 *sin(X[1])\nend\n\nlb = -ones(4)*π\nub = ones(4)*π\n\nres1 = gsa(ishi,eFAST(),[[lb[i],ub[i]] for i in 1:4],samples=15000)\n\n##with batching\nfunction ishi_batch(X)\n    A= 7\n    B= 0.1\n    @. sin(X[1,:]) + A*sin(X[2,:])^2+ B*X[3,:]^4 *sin(X[1,:])\nend\n\nres2 = gsa(ishi_batch,eFAST(),[[lb[i],ub[i]] for i in 1:4],samples=15000,batch=true)\n\n\n\n\n\n\n","category":"type"},{"location":"methods/morris/#Morris-Method","page":"Morris Method","title":"Morris Method","text":"","category":"section"},{"location":"methods/morris/","page":"Morris Method","title":"Morris Method","text":"Morris","category":"page"},{"location":"methods/morris/#GlobalSensitivity.Morris","page":"Morris Method","title":"GlobalSensitivity.Morris","text":"Morris(; p_steps::Array{Int, 1} = Int[], relative_scale::Bool = false,\n            num_trajectory::Int = 10,\n            total_num_trajectory::Int = 5 * num_trajectory, len_design_mat::Int = 10)\n\np_steps: Vector of Delta for the step sizes in each direction. Required.\nrelative_scale: The elementary effects are calculated with the assumption that the parameters lie in the range [0,1] but as this is not always the case scaling is used to get more informative, scaled effects. Defaults to false.\ntotal_num_trajectory, num_trajectory: The total number of design matrices that are generated out of which num_trajectory matrices with the highest spread are used in calculation.\nlen_design_mat: The size of a design matrix.\n\nMethod Details\n\nThe Morris method also known as Morris’s OAT method where OAT stands for One At a Time can be described in the following steps:\n\nWe calculate local sensitivity measures known as “elementary effects”, which are calculated by measuring the perturbation in the output of the model on changing one parameter.\n\nEE_i = fracf(x_1x_2x_i+ Deltax_k) - yDelta\n\nThese are evaluated at various points in the input chosen such that a wide “spread” of the parameter space is explored and considered in the analysis, to provide an approximate global importance measure. The mean and variance of these elementary effects is computed. A high value of the mean implies that a parameter is important, a high variance implies that its effects are non-linear or the result of interactions with other inputs. This method does not evaluate separately the contribution from the interaction and the contribution of the parameters individually and gives the effects for each parameter which takes into consideration all the interactions and its individual contribution.\n\nAPI\n\ngsa(f, method::Morris, p_range::AbstractVector; batch = false,\n         rng::AbstractRNG = Random.default_rng(), kwargs...)\n\nExample\n\nMorris method on Ishigami function\n\nusing GlobalSensitivity\n\nfunction ishi(X)\n    A= 7\n    B= 0.1\n    sin(X[1]) + A*sin(X[2])^2+ B*X[3]^4 *sin(X[1])\nend\n\nlb = -ones(4)*π\nub = ones(4)*π\n\nm = gsa(ishi, Morris(num_trajectory=500000), [[lb[i],ub[i]] for i in 1:4])\n\n\n\n\n\n","category":"type"},{"location":"methods/sobol/#Sobol-Method","page":"Sobol Method","title":"Sobol Method","text":"","category":"section"},{"location":"methods/sobol/","page":"Sobol Method","title":"Sobol Method","text":"Sobol","category":"page"},{"location":"methods/sobol/#GlobalSensitivity.Sobol","page":"Sobol Method","title":"GlobalSensitivity.Sobol","text":"Sobol(; order = [0, 1], nboot = 1, conf_level = 0.95)\n\norder: the order of the indices to calculate. Defaults to [0,1], which means the Total and First order indices. Passing 2 enables calculation of the Second order indices as well.\nnboot: for confidence interval calculation nboot should be specified for the number (>0) of bootstrap runs.\nconf_level: the confidence level, the default for which is 0.95.\n\nMethod Details\n\nSobol is a variance-based method and it decomposes the variance of the output of the model or system into fractions which can be attributed to inputs or sets of inputs. This helps to get not just the individual parameter's sensitivities but also gives a way to quantify the affect and sensitivity from the interaction between the parameters.\n\n Y = f_0+ sum_i=1^d f_i(X_i)+ sum_i  j^d f_ij(X_iX_j)  + f_12d(X_1X_2X_d)\n\n Var(Y) = sum_i=1^d V_i + sum_i  j^d V_ij +  + V_12d\n\nThe Sobol Indices are \"order\"ed, the first order indices given by S_i = fracV_iVar(Y) the contribution to the output variance of the main effect of X_i, therefore it measures the effect of varying X_i alone, but averaged over variations in other input parameters. It is standardised by the total variance to provide a fractional contribution. Higher-order interaction indices S_ij S_ijk and so on can be formed by dividing other terms in the variance decomposition by Var(Y).\n\nAPI\n\ngsa(f, method::Sobol, p_range::AbstractVector; samples, kwargs...)\ngsa(f, method::Sobol, A::AbstractMatrix{TA}, B::AbstractMatrix;\n         batch = false, Ei_estimator = :Jansen1999,\n         distributed::Val{SHARED_ARRAY} = Val(false),\n         kwargs...) where {TA, SHARED_ARRAY}\n\nEi_estimator can take :Homma1996, :Sobol2007 and :Jansen1999 for which   Monte Carlo estimator is used for the Ei term. Defaults to :Jansen1999. Details for these can be found in the   corresponding papers:\n\n:Homma1996 - Homma, T. and Saltelli, A., 1996. Importance measures in global sensitivity analysis of nonlinear models. Reliability Engineering & System Safety, 52(1), pp.1-17.\n:Sobol2007 - I.M. Sobol, S. Tarantola, D. Gatelli, S.S. Kucherenko and W. Mauntz, 2007, Estimating the approx- imation errors when fixing unessential factors in global sensitivity analysis, Reliability Engineering and System Safety, 92, 957–960. and A. Saltelli, P. Annoni, I. Azzini, F. Campolongo, M. Ratto and S. Tarantola, 2010, Variance based sensitivity analysis of model output. Design and estimator for the total sensitivity index, Computer Physics Communications 181, 259–270.\n:Jansen1999 - M.J.W. Jansen, 1999, Analysis of variance designs for model output, Computer Physics Communi- cation, 117, 35–43.\n\nExample\n\nusing GlobalSensitivity, QuasiMonteCarlo\n\nfunction ishi(X)\n    A= 7\n    B= 0.1\n    sin(X[1]) + A*sin(X[2])^2+ B*X[3]^4 *sin(X[1])\nend\n\nsamples = 600000\nlb = -ones(4)*π\nub = ones(4)*π\nsampler = SobolSample()\nA,B = QuasiMonteCarlo.generate_design_matrices(samples,lb,ub,sampler)\n\nres1 = gsa(ishi,Sobol(order=[0,1,2]),A,B)\n\nfunction ishi_batch(X)\n    A= 7\n    B= 0.1\n    @. sin(X[1,:]) + A*sin(X[2,:])^2+ B*X[3,:]^4 *sin(X[1,:])\nend\n\nres2 = gsa(ishi_batch,Sobol(),A,B,batch=true)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/juliacon21/#Global-Sensitivity-Analysis-of-the-Lotka-Volterra-model","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"","category":"section"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"The tutorial covers a workflow of using GlobalSensitivity.jl on the Lotka-Volterra differential equations. We showcase how to use multiple GSA methods, analyse their results and leverage Julia's parallelism capabilities to perform Global Sensitivity analysis at scale.","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"using GlobalSensitivity, QuasiMonteCarlo, OrdinaryDiffEq, Statistics, CairoMakie\n\nfunction f(du,u,p,t)\n  du[1] = p[1]*u[1] - p[2]*u[1]*u[2] #prey\n  du[2] = -p[3]*u[2] + p[4]*u[1]*u[2] #predator\nend\n\nu0 = [1.0;1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(f,u0,tspan,p)\nt = collect(range(0, stop=10, length=200))\n\n\nf1 = function (p)\n    prob1 = remake(prob;p=p)\n    sol = solve(prob1,Tsit5();saveat=t)\n    return [mean(sol[1,:]), maximum(sol[2,:])]\nend\n\nbounds = [[1,5],[1,5],[1,5],[1,5]]\n\nreg_sens = gsa(f1, RegressionGSA(true), bounds, samples = 200)\nfig = Figure(resolution = (600, 400))\nax, hm = CairoMakie.heatmap(fig[1,1], reg_sens.partial_correlation, axis = (xticksvisible = false,yticksvisible = false, yticklabelsvisible = false, xticklabelsvisible = false, title = \"Partial correlation\"))\nColorbar(fig[1, 2], hm)\nax, hm = CairoMakie.heatmap(fig[2,1], reg_sens.standard_regression, axis = (xticksvisible = false,yticksvisible = false, yticklabelsvisible = false, xticklabelsvisible = false, title = \"Standard regression\"))\nColorbar(fig[2, 2], hm)\nfig","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"(Image: heatmapreg)","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"using StableRNGs\n_rng = StableRNG(1234)\nmorris_sens = gsa(f1, Morris(), bounds, rng = _rng)\nfig = Figure(resolution = (600, 400))\nscatter(fig[1,1], [1,2,3,4], morris_sens.means_star[1,:], color = :green, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Prey\",))\nscatter(fig[1,2], [1,2,3,4], morris_sens.means_star[2,:], color = :red, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Predator\",))\nfig","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"(Image: morrisscat)","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"sobol_sens = gsa(f1, Sobol(), bounds, samples=500)\nefast_sens = gsa(f1, eFAST(), bounds, samples=500)\nfig = Figure(resolution = (600, 400))\nbarplot(fig[1,1], [1,2,3,4], sobol_sens.S1[1, :], color = :green, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Prey (Sobol)\", ylabel = \"First order\"))\nbarplot(fig[2,1], [1,2,3,4], sobol_sens.ST[1, :], color = :green, axis = (xticksvisible = false, xticklabelsvisible = false, ylabel = \"Total order\"))\nbarplot(fig[1,2], [1,2,3,4], efast_sens.S1[1, :], color = :red, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Prey (eFAST)\"))\nbarplot(fig[2,2], [1,2,3,4], efast_sens.ST[1, :], color = :red, axis = (xticksvisible = false, xticklabelsvisible = false))\nfig\n\nfig = Figure(resolution = (600, 400))\nbarplot(fig[1,1], [1,2,3,4], sobol_sens.S1[2, :], color = :green, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Predator (Sobol)\", ylabel = \"First order\"))\nbarplot(fig[2,1], [1,2,3,4], sobol_sens.ST[2, :], color = :green, axis = (xticksvisible = false, xticklabelsvisible = false, ylabel = \"Total order\"))\nbarplot(fig[1,2], [1,2,3,4], efast_sens.S1[2, :], color = :red, axis = (xticksvisible = false, xticklabelsvisible = false, title = \"Predator (eFAST)\"))\nbarplot(fig[2,2], [1,2,3,4], efast_sens.ST[2, :], color = :red, axis = (xticksvisible = false, xticklabelsvisible = false))\nfig","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"(Image: sobolefastprey) (Image: sobolefastpred)","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"using QuasiMonteCarlo\nsamples = 500\nlb = [1.0, 1.0, 1.0, 1.0]\nub = [5.0, 5.0, 5.0, 5.0]\nsampler = SobolSample()\nA,B = QuasiMonteCarlo.generate_design_matrices(samples,lb,ub,sampler)\nsobol_sens_desmat = gsa(f1,Sobol(),A,B)\n\n\nf_batch = function (p)\n  prob_func(prob,i,repeat) = remake(prob;p=p[:,i])\n  ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)\n\n  sol = solve(ensemble_prob, Tsit5(), EnsembleThreads(); saveat=t, trajectories=size(p,2))\n\n  out = zeros(2,size(p,2))\n\n  for i in 1:size(p,2)\n    out[1,i] = mean(sol[i][1,:])\n    out[2,i] = maximum(sol[i][2,:])\n  end\n\n  return out\nend\n\nsobol_sens_batch = gsa(f_batch,Sobol(),A,B,batch=true)\n\n@time gsa(f1,Sobol(),A,B)\n@time gsa(f_batch,Sobol(),A,B,batch=true)","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"f1 = function (p)\n           prob1 = remake(prob;p=p)\n           sol = solve(prob1,Tsit5();saveat=t)\n       end\nsobol_sens = gsa(f1, Sobol(nboot = 20), bounds, samples=500)\nfig = Figure(resolution = (600, 400))\nax, hm = CairoMakie.scatter(fig[1,1], sobol_sens.S1[1][1,2:end], label = \"Prey\", markersize = 4)\nCairoMakie.scatter!(fig[1,1], sobol_sens.S1[1][2,2:end], label = \"Predator\", markersize = 4)\n\n# Legend(fig[1,2], ax)\n\nax, hm = CairoMakie.scatter(fig[1,2], sobol_sens.S1[2][1,2:end], label = \"Prey\", markersize = 4)\nCairoMakie.scatter!(fig[1,2], sobol_sens.S1[2][2,2:end], label = \"Predator\", markersize = 4)\n\nax, hm = CairoMakie.scatter(fig[2,1], sobol_sens.S1[3][1,2:end], label = \"Prey\", markersize = 4)\nCairoMakie.scatter!(fig[2,1], sobol_sens.S1[3][2,2:end], label = \"Predator\", markersize = 4)\n\nax, hm = CairoMakie.scatter(fig[2,2], sobol_sens.S1[4][1,2:end], label = \"Prey\", markersize = 4)\nCairoMakie.scatter!(fig[2,2], sobol_sens.S1[4][2,2:end], label = \"Predator\", markersize = 4)\n\ntitle = Label(fig[0,:], \"First order Sobol indices\")\nlegend = Legend(fig[2,3], ax)","category":"page"},{"location":"tutorials/juliacon21/","page":"Global Sensitivity Analysis of the Lotka-Volterra model","title":"Global Sensitivity Analysis of the Lotka-Volterra model","text":"(Image: timeseriessobollv)","category":"page"},{"location":"methods/rbdfast/#Random-Balance-Design-FAST-Method","page":"Random Balance Design FAST Method","title":"Random Balance Design FAST Method","text":"","category":"section"},{"location":"methods/rbdfast/","page":"Random Balance Design FAST Method","title":"Random Balance Design FAST Method","text":"RBDFAST","category":"page"},{"location":"methods/rbdfast/#GlobalSensitivity.RBDFAST","page":"Random Balance Design FAST Method","title":"GlobalSensitivity.RBDFAST","text":"RBDFAST(; num_harmonics = 6)\n\nnum_harmonics: Number of harmonics to consider during power spectral density analysis.\n\nMethod Details\n\nIn the Random Balance Designs (RBD) method, similar to eFAST,  samples points are selected over a curve in the input space. A fixed frequency equal to 1 is used for each factor. Then independent random permutations are applied to the coordinates of the samples points in order to generate the design points. The input model for analysis is evaluated at each design point and the outputs are reordered such that the design points are in increasing order with respect to factor Xi. The Fourier spectrum is calculated on the model output at the frequency 1 and at its higher harmonics (2, 3, 4, 5, 6) and yields the estimate of the sensitivity index of factor Xi.\n\nAPI\n\ngsa(f, method::RBDFAST; num_params, samples,\n         rng::AbstractRNG = Random.default_rng(), batch = false, kwargs...)\n\nExample\n\nfunction linear_batch(X)\n    A= 7\n    B= 0.1\n    @. A*X[1,:]+B*X[2,:]\nend\nfunction linear(X)\n    A= 7\n    B= 0.1\n    A*X[1]+B*X[2]\nend\n\nlb = -ones(4)*π\nub = ones(4)*π\n\nrng = StableRNG(123)\nres1 = gsa(linear,GlobalSensitivity.RBDFAST(),num_params = 4, samples=15000)\nres2 = gsa(linear_batch,GlobalSensitivity.RBDFAST(),num_params = 4, batch=true, samples=15000)\n\n\n\n\n\n","category":"type"},{"location":"methods/dgsm/#Derivative-based-Global-Sensitivity-Measure-Method","page":"Derivative based Global Sensitivity Measure Method","title":"Derivative based Global Sensitivity Measure Method","text":"","category":"section"},{"location":"methods/dgsm/","page":"Derivative based Global Sensitivity Measure Method","title":"Derivative based Global Sensitivity Measure Method","text":"DGSM","category":"page"},{"location":"methods/dgsm/#GlobalSensitivity.DGSM","page":"Derivative based Global Sensitivity Measure Method","title":"GlobalSensitivity.DGSM","text":"DGSM(; crossed::Bool = false)\n\ncrossed: A Boolean which act as indicator for computation of DGSM crossed indices.\n\nMethod Details\n\nThe DGSM method takes a probability distribution for each of the parameters and samples are obtained from the distributions to create random parameter sets. Derivatives of the function being analysed are then computed at the sampled parameters and specific statistics of those derivatives are used. The paper by Sobol and Kucherenko discusses the relationship between the DGSM results, tao and sigma and the Morris elementary effects and Sobol Indices.\n\nAPI\n\ngsa(f, method::DGSM, distr::AbstractArray; samples::Int, kwargs...)\n\ndist: Array of distribution of respective variables. E.g. dist = [Normal(5,6),Uniform(2,3)] for two variables.\n\nExample\n\nusing GlobalSensitivity, Test, Distributions\n\nsamples = 2000000\n\nf1(x) = x[1] + 2*x[2] + 6.00*x[3]\ndist1 = [Uniform(4,10),Normal(4,23),Beta(2,3)]\nb =  gsa(f1,DGSM(),dist1,samples=samples)\n\n\n\n\n\n","category":"type"},{"location":"methods/delta/#Delta-Moment-Independent-Method","page":"Delta Moment-Independent Method","title":"Delta Moment-Independent Method","text":"","category":"section"},{"location":"methods/delta/","page":"Delta Moment-Independent Method","title":"Delta Moment-Independent Method","text":"DeltaMoment","category":"page"},{"location":"methods/delta/#GlobalSensitivity.DeltaMoment","page":"Delta Moment-Independent Method","title":"GlobalSensitivity.DeltaMoment","text":"DeltaMoment(; nboot = 500, conf_level = 0.95, Ygrid_length = 2048,\n                 num_classes = nothing)\n\nnboot: number of bootstrap repetions. Defaults to 500.\nconf_level: the level used for confidence interval calculation with bootstrap. Default value of 0.95.\nYgrid_length: number of quadrature points to consider when performing the kernel density estimation and the integration steps. Should be a power of 2 for efficient FFT in kernel density estimates. Defaults to 2048.\nnum_classes: Determine how many classes to split each factor into to when generating distributions of model output conditioned on class.\n\nMethod Details\n\nThe Delta moment-independent method relies on new estimators for density-based statistics.  It allows for the estimation of both distribution-based sensitivity measures and of sensitivity measures that look at contributions to a specific moment. One of the primary advantage of this method is the independence of computation cost from the number of parameters.\n\nnote: Note\nDeltaMoment only works for scalar output.\n\nAPI\n\ngsa(f, method::DeltaMoment, p_range; samples, batch = false,\n         rng::AbstractRNG = Random.default_rng())\ngsa(X, Y, method::DeltaMoment; rng::AbstractRNG = Random.default_rng())\n\nExample\n\nusing GlobalSensitivity, Test\n\nfunction ishi(X)\n    A= 7\n    B= 0.1\n    sin(X[1]) + A*sin(X[2])^2+ B*X[3]^4 *sin(X[1])\nend\n\nlb = -ones(3)*π\nub = ones(3)*π\n\nm = gsa(ishi,DeltaMoment(),fill([lb[1], ub[1]], 3), samples=1000)\n\n\nsamples = 1000\nX = QuasiMonteCarlo.sample(samples, lb, ub, QuasiMonteCarlo.SobolSample())\nY = ishi.(@view X[:, i] for i in 1:samples)\n\nm = gsa(X, Y, DeltaMoment())\n\n\n\n\n\n","category":"type"},{"location":"#GlobalSensitivity.jl:-Robust,-Fast,-and-Parallel-Global-Sensitivity-Analysis-(GSA)-in-Julia","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Robust, Fast, and Parallel Global Sensitivity Analysis (GSA) in Julia","text":"","category":"section"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"Global Sensitivity Analysis (GSA) methods are used to quantify the uncertainty in output of a model with respect to the parameters. These methods allow practitioners to measure both parameter's individual contributions and the contribution of their interactions to the output uncertainity.","category":"page"},{"location":"#Installation","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"Installation","text":"","category":"section"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"To use this functionality, you must install GlobalSensitivity.jl:","category":"page"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"]add GlobalSensitivity\nusing GlobalSensitivity","category":"page"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"Note: GlobalSensitivity.jl is unrelated to the GlobalSensitivityAnalysis.jl package.","category":"page"},{"location":"#General-Interface","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"General Interface","text":"","category":"section"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"The general interface for performing global sensitivity analysis using this package is:","category":"page"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"gsa(f, method::GlobalSensitivity.GSAMethod, param_range; samples, batch = false)","category":"page"},{"location":"#GlobalSensitivity.gsa-Tuple{Any,GlobalSensitivity.GSAMethod,Any}","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.gsa","text":"gsa(f, method::GSAMethod, param_range; samples, batch=false)\n\nwhere:\n\ny=f(x) is a function that takes in a single vector and spits out a single vector or scalar. If batch=true, then f takes in a matrix where each row is a set of parameters, and returns a matrix where each row is a the output for the corresponding row of parameters.\nmethod is one of the available GSA methods.\nparam_range is a vector of tuples for the upper and lower bound for the given parameter i.\nsamples is a required keyword argument for the number of samples of parameters for the design matrix. Note that this is not relevant for Fractional Factorial Method and Morris Method.\n\nAdditionally,\n\nFor Delta Moment-Independent Method, EASI Method and Regression Method input and output matrix based method as follows is available:\n\nres = gsa(X, Y, method)\n\nwhere:\n\nX is the number of parameters * samples matrix with parameter values.\nY is the output dimension * number of samples matrix with out evaluated at X's columns.\nmethod is one of the GSA methods below.\n\nFor Sobol Method one can use the following design matrices based method instead of parameter range based method discussed earlier:\n\neffects = gsa(f, method, A, B; batch=false)\n\nwhere A and B are design matrices with each row being a set of parameters. Note that generate_design_matrices from QuasiMonteCarlo.jl can be used to generate the design matrices.\n\n\n\n\n\n","category":"method"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"The descriptions of the available methods can be found in the Methods section. The gsa interface allows for utilizing batched functions with the batch kwarg discussed above for parallel computation of GSA results.","category":"page"},{"location":"#Citing","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"Citing","text":"","category":"section"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"If you use this software in your work, please cite:","category":"page"},{"location":"","page":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","title":"GlobalSensitivity.jl: Global Sensitivity Analysis (GSA)","text":"@article{dixit2022globalsensitivity,\n  title={GlobalSensitivity. jl: Performant and Parallel Global Sensitivity Analysis with Julia},\n  author={Dixit, Vaibhav Kumar and Rackauckas, Christopher},\n  journal={Journal of Open Source Software},\n  volume={7},\n  number={76},\n  pages={4561},\n  year={2022}\n}","category":"page"}]
}
